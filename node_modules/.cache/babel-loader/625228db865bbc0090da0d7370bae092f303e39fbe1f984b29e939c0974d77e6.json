{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { equal } from \"@wry/equality\";\nimport { createFulfilledPromise, createRejectedPromise } from \"../../../utilities/index.js\";\nimport { wrapPromiseWithState } from \"../../../utilities/index.js\";\nimport { invariant } from \"../../../utilities/globals/invariantWrappers.js\";\nvar QUERY_REFERENCE_SYMBOL = Symbol.for(\"apollo.internal.queryRef\");\nvar PROMISE_SYMBOL = Symbol.for(\"apollo.internal.refPromise\");\nexport function wrapQueryRef(internalQueryRef) {\n  var _a;\n  var ref = (_a = {\n    toPromise: function () {\n      // We avoid resolving this promise with the query data because we want to\n      // discourage using the server data directly from the queryRef. Instead,\n      // the data should be accessed through `useReadQuery`. When the server\n      // data is needed, its better to use `client.query()` directly.\n      //\n      // Here we resolve with the ref itself to make using this in React Router\n      // or TanStack Router `loader` functions a bit more ergonomic e.g.\n      //\n      // function loader() {\n      //   return { queryRef: await preloadQuery(query).toPromise() }\n      // }\n      return getWrappedPromise(ref).then(function () {\n        return ref;\n      });\n    }\n  }, _a[QUERY_REFERENCE_SYMBOL] = internalQueryRef, _a[PROMISE_SYMBOL] = internalQueryRef.promise, _a);\n  return ref;\n}\nexport function assertWrappedQueryRef(queryRef) {\n  invariant(!queryRef || QUERY_REFERENCE_SYMBOL in queryRef, 69);\n}\nexport function getWrappedPromise(queryRef) {\n  var internalQueryRef = unwrapQueryRef(queryRef);\n  return internalQueryRef.promise.status === \"fulfilled\" ? internalQueryRef.promise : queryRef[PROMISE_SYMBOL];\n}\nexport function unwrapQueryRef(queryRef) {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\nexport function updateWrappedQueryRef(queryRef, promise) {\n  queryRef[PROMISE_SYMBOL] = promise;\n}\nvar OBSERVED_CHANGED_OPTIONS = [\"canonizeResults\", \"context\", \"errorPolicy\", \"fetchPolicy\", \"refetchWritePolicy\", \"returnPartialData\"];\nvar InternalQueryReference = /** @class */function () {\n  function InternalQueryReference(observable, options) {\n    var _this = this;\n    this.key = {};\n    this.listeners = new Set();\n    this.references = 0;\n    this.softReferences = 0;\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n    this.setResult();\n    this.subscribeToQuery();\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    var startDisposeTimer = function () {\n      var _a;\n      if (!_this.references) {\n        _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a = options.autoDisposeTimeoutMs) !== null && _a !== void 0 ? _a : 30000);\n      }\n    };\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n  Object.defineProperty(InternalQueryReference.prototype, \"disposed\", {\n    get: function () {\n      return this.subscription.closed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InternalQueryReference.prototype, \"watchQueryOptions\", {\n    get: function () {\n      return this.observable.options;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  InternalQueryReference.prototype.reinitialize = function () {\n    var observable = this.observable;\n    var originalFetchPolicy = this.watchQueryOptions.fetchPolicy;\n    var avoidNetworkRequests = originalFetchPolicy === \"no-cache\" || originalFetchPolicy === \"standby\";\n    try {\n      if (avoidNetworkRequests) {\n        observable.silentSetOptions({\n          fetchPolicy: \"standby\"\n        });\n      } else {\n        observable.resetLastResults();\n        observable.silentSetOptions({\n          fetchPolicy: \"cache-first\"\n        });\n      }\n      this.subscribeToQuery();\n      if (avoidNetworkRequests) {\n        return;\n      }\n      observable.resetDiff();\n      this.setResult();\n    } finally {\n      observable.silentSetOptions({\n        fetchPolicy: originalFetchPolicy\n      });\n    }\n  };\n  InternalQueryReference.prototype.retain = function () {\n    var _this = this;\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    var disposed = false;\n    return function () {\n      if (disposed) {\n        return;\n      }\n      disposed = true;\n      _this.references--;\n      setTimeout(function () {\n        if (!_this.references) {\n          _this.dispose();\n        }\n      });\n    };\n  };\n  InternalQueryReference.prototype.softRetain = function () {\n    var _this = this;\n    this.softReferences++;\n    var disposed = false;\n    return function () {\n      // Tracking if this has already been called helps ensure that\n      // multiple calls to this function won't decrement the reference\n      // counter more than it should. Subsequent calls just result in a noop.\n      if (disposed) {\n        return;\n      }\n      disposed = true;\n      _this.softReferences--;\n      setTimeout(function () {\n        if (!_this.softReferences && !_this.references) {\n          _this.dispose();\n        }\n      });\n    };\n  };\n  InternalQueryReference.prototype.didChangeOptions = function (watchQueryOptions) {\n    var _this = this;\n    return OBSERVED_CHANGED_OPTIONS.some(function (option) {\n      return option in watchQueryOptions && !equal(_this.watchQueryOptions[option], watchQueryOptions[option]);\n    });\n  };\n  InternalQueryReference.prototype.applyOptions = function (watchQueryOptions) {\n    var _a = this.watchQueryOptions,\n      currentFetchPolicy = _a.fetchPolicy,\n      currentCanonizeResults = _a.canonizeResults;\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (currentFetchPolicy === \"standby\" && currentFetchPolicy !== watchQueryOptions.fetchPolicy) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.silentSetOptions(watchQueryOptions);\n      if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {\n        this.result = __assign(__assign({}, this.result), this.observable.getCurrentResult());\n        this.promise = createFulfilledPromise(this.result);\n      }\n    }\n    return this.promise;\n  };\n  InternalQueryReference.prototype.listen = function (listener) {\n    var _this = this;\n    this.listeners.add(listener);\n    return function () {\n      _this.listeners.delete(listener);\n    };\n  };\n  InternalQueryReference.prototype.refetch = function (variables) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  };\n  InternalQueryReference.prototype.fetchMore = function (options) {\n    return this.initiateFetch(this.observable.fetchMore(options));\n  };\n  InternalQueryReference.prototype.dispose = function () {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  };\n  InternalQueryReference.prototype.onDispose = function () {\n    // noop. overridable by options\n  };\n  InternalQueryReference.prototype.handleNext = function (result) {\n    var _a;\n    switch (this.promise.status) {\n      case \"pending\":\n        {\n          // Maintain the last successful `data` value if the next result does not\n          // have one.\n          if (result.data === void 0) {\n            result.data = this.result.data;\n          }\n          this.result = result;\n          (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, result);\n          break;\n        }\n      default:\n        {\n          // This occurs when switching to a result that is fully cached when this\n          // class is instantiated. ObservableQuery will run reobserve when\n          // subscribing, which delivers a result from the cache.\n          if (result.data === this.result.data && result.networkStatus === this.result.networkStatus) {\n            return;\n          }\n          // Maintain the last successful `data` value if the next result does not\n          // have one.\n          if (result.data === void 0) {\n            result.data = this.result.data;\n          }\n          this.result = result;\n          this.promise = createFulfilledPromise(result);\n          this.deliver(this.promise);\n          break;\n        }\n    }\n  };\n  InternalQueryReference.prototype.handleError = function (error) {\n    var _a;\n    this.subscription.unsubscribe();\n    this.subscription = this.observable.resubscribeAfterError(this.handleNext, this.handleError);\n    switch (this.promise.status) {\n      case \"pending\":\n        {\n          (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, error);\n          break;\n        }\n      default:\n        {\n          this.promise = createRejectedPromise(error);\n          this.deliver(this.promise);\n        }\n    }\n  };\n  InternalQueryReference.prototype.deliver = function (promise) {\n    this.listeners.forEach(function (listener) {\n      return listener(promise);\n    });\n  };\n  InternalQueryReference.prototype.initiateFetch = function (returnedPromise) {\n    var _this = this;\n    this.promise = this.createPendingPromise();\n    this.promise.catch(function () {});\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise.then(function () {\n      // In the case of `fetchMore`, this promise is resolved before a cache\n      // result is emitted due to the fact that `fetchMore` sets a `no-cache`\n      // fetch policy and runs `cache.batch` in its `.then` handler. Because\n      // the timing is different, we accidentally run this update twice\n      // causing an additional re-render with the `fetchMore` result by\n      // itself. By wrapping in `setTimeout`, this should provide a short\n      // delay to allow the `QueryInfo.notify` handler to run before this\n      // promise is checked.\n      // See https://github.com/apollographql/apollo-client/issues/11315 for\n      // more information\n      setTimeout(function () {\n        var _a;\n        if (_this.promise.status === \"pending\") {\n          // Use the current result from the observable instead of the value\n          // resolved from the promise. This avoids issues in some cases where\n          // the raw resolved value should not be the emitted value, such as\n          // when a `fetchMore` call returns an empty array after it has\n          // reached the end of the list.\n          //\n          // See the following for more information:\n          // https://github.com/apollographql/apollo-client/issues/11642\n          _this.result = _this.observable.getCurrentResult();\n          (_a = _this.resolve) === null || _a === void 0 ? void 0 : _a.call(_this, _this.result);\n        }\n      });\n    }).catch(function (error) {\n      var _a;\n      return (_a = _this.reject) === null || _a === void 0 ? void 0 : _a.call(_this, error);\n    });\n    return returnedPromise;\n  };\n  InternalQueryReference.prototype.subscribeToQuery = function () {\n    var _this = this;\n    this.subscription = this.observable.filter(function (result) {\n      return !equal(result.data, {}) && !equal(result, _this.result);\n    }).subscribe(this.handleNext, this.handleError);\n  };\n  InternalQueryReference.prototype.setResult = function () {\n    // Don't save this result as last result to prevent delivery of last result\n    // when first subscribing\n    var result = this.observable.getCurrentResult(false);\n    if (equal(result, this.result)) {\n      return;\n    }\n    this.result = result;\n    this.promise = result.data && (!result.partial || this.watchQueryOptions.returnPartialData) ? createFulfilledPromise(result) : this.createPendingPromise();\n  };\n  InternalQueryReference.prototype.createPendingPromise = function () {\n    var _this = this;\n    return wrapPromiseWithState(new Promise(function (resolve, reject) {\n      _this.resolve = resolve;\n      _this.reject = reject;\n    }));\n  };\n  return InternalQueryReference;\n}();\nexport { InternalQueryReference };","map":{"version":3,"names":["__assign","equal","createFulfilledPromise","createRejectedPromise","wrapPromiseWithState","invariant","QUERY_REFERENCE_SYMBOL","Symbol","for","PROMISE_SYMBOL","wrapQueryRef","internalQueryRef","_a","ref","toPromise","getWrappedPromise","then","promise","assertWrappedQueryRef","queryRef","unwrapQueryRef","status","updateWrappedQueryRef","OBSERVED_CHANGED_OPTIONS","InternalQueryReference","observable","options","_this","key","listeners","Set","references","softReferences","handleNext","bind","handleError","dispose","onDispose","setResult","subscribeToQuery","startDisposeTimer","autoDisposeTimeoutId","setTimeout","autoDisposeTimeoutMs","Object","defineProperty","prototype","get","subscription","closed","enumerable","configurable","reinitialize","originalFetchPolicy","watchQueryOptions","fetchPolicy","avoidNetworkRequests","silentSetOptions","resetLastResults","resetDiff","retain","clearTimeout","disposed","softRetain","didChangeOptions","some","option","applyOptions","currentFetchPolicy","currentCanonizeResults","canonizeResults","initiateFetch","reobserve","result","getCurrentResult","listen","listener","add","delete","refetch","variables","fetchMore","unsubscribe","data","resolve","call","networkStatus","deliver","error","resubscribeAfterError","reject","forEach","returnedPromise","createPendingPromise","catch","filter","subscribe","partial","returnPartialData","Promise"],"sources":["C:/Users/hp/Desktop/Projetyacine/agence-voyage/node_modules/@apollo/client/react/internal/cache/QueryReference.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { equal } from \"@wry/equality\";\nimport { createFulfilledPromise, createRejectedPromise, } from \"../../../utilities/index.js\";\nimport { wrapPromiseWithState } from \"../../../utilities/index.js\";\nimport { invariant } from \"../../../utilities/globals/invariantWrappers.js\";\nvar QUERY_REFERENCE_SYMBOL = Symbol.for(\"apollo.internal.queryRef\");\nvar PROMISE_SYMBOL = Symbol.for(\"apollo.internal.refPromise\");\nexport function wrapQueryRef(internalQueryRef) {\n    var _a;\n    var ref = (_a = {\n            toPromise: function () {\n                // We avoid resolving this promise with the query data because we want to\n                // discourage using the server data directly from the queryRef. Instead,\n                // the data should be accessed through `useReadQuery`. When the server\n                // data is needed, its better to use `client.query()` directly.\n                //\n                // Here we resolve with the ref itself to make using this in React Router\n                // or TanStack Router `loader` functions a bit more ergonomic e.g.\n                //\n                // function loader() {\n                //   return { queryRef: await preloadQuery(query).toPromise() }\n                // }\n                return getWrappedPromise(ref).then(function () { return ref; });\n            }\n        },\n        _a[QUERY_REFERENCE_SYMBOL] = internalQueryRef,\n        _a[PROMISE_SYMBOL] = internalQueryRef.promise,\n        _a);\n    return ref;\n}\nexport function assertWrappedQueryRef(queryRef) {\n    invariant(!queryRef || QUERY_REFERENCE_SYMBOL in queryRef, 69);\n}\nexport function getWrappedPromise(queryRef) {\n    var internalQueryRef = unwrapQueryRef(queryRef);\n    return internalQueryRef.promise.status === \"fulfilled\" ?\n        internalQueryRef.promise\n        : queryRef[PROMISE_SYMBOL];\n}\nexport function unwrapQueryRef(queryRef) {\n    return queryRef[QUERY_REFERENCE_SYMBOL];\n}\nexport function updateWrappedQueryRef(queryRef, promise) {\n    queryRef[PROMISE_SYMBOL] = promise;\n}\nvar OBSERVED_CHANGED_OPTIONS = [\n    \"canonizeResults\",\n    \"context\",\n    \"errorPolicy\",\n    \"fetchPolicy\",\n    \"refetchWritePolicy\",\n    \"returnPartialData\",\n];\nvar InternalQueryReference = /** @class */ (function () {\n    function InternalQueryReference(observable, options) {\n        var _this = this;\n        this.key = {};\n        this.listeners = new Set();\n        this.references = 0;\n        this.softReferences = 0;\n        this.handleNext = this.handleNext.bind(this);\n        this.handleError = this.handleError.bind(this);\n        this.dispose = this.dispose.bind(this);\n        this.observable = observable;\n        if (options.onDispose) {\n            this.onDispose = options.onDispose;\n        }\n        this.setResult();\n        this.subscribeToQuery();\n        // Start a timer that will automatically dispose of the query if the\n        // suspended resource does not use this queryRef in the given time. This\n        // helps prevent memory leaks when a component has unmounted before the\n        // query has finished loading.\n        var startDisposeTimer = function () {\n            var _a;\n            if (!_this.references) {\n                _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a = options.autoDisposeTimeoutMs) !== null && _a !== void 0 ? _a : 30000);\n            }\n        };\n        // We wait until the request has settled to ensure we don't dispose of the\n        // query ref before the request finishes, otherwise we would leave the\n        // promise in a pending state rendering the suspense boundary indefinitely.\n        this.promise.then(startDisposeTimer, startDisposeTimer);\n    }\n    Object.defineProperty(InternalQueryReference.prototype, \"disposed\", {\n        get: function () {\n            return this.subscription.closed;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(InternalQueryReference.prototype, \"watchQueryOptions\", {\n        get: function () {\n            return this.observable.options;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    InternalQueryReference.prototype.reinitialize = function () {\n        var observable = this.observable;\n        var originalFetchPolicy = this.watchQueryOptions.fetchPolicy;\n        var avoidNetworkRequests = originalFetchPolicy === \"no-cache\" || originalFetchPolicy === \"standby\";\n        try {\n            if (avoidNetworkRequests) {\n                observable.silentSetOptions({ fetchPolicy: \"standby\" });\n            }\n            else {\n                observable.resetLastResults();\n                observable.silentSetOptions({ fetchPolicy: \"cache-first\" });\n            }\n            this.subscribeToQuery();\n            if (avoidNetworkRequests) {\n                return;\n            }\n            observable.resetDiff();\n            this.setResult();\n        }\n        finally {\n            observable.silentSetOptions({ fetchPolicy: originalFetchPolicy });\n        }\n    };\n    InternalQueryReference.prototype.retain = function () {\n        var _this = this;\n        this.references++;\n        clearTimeout(this.autoDisposeTimeoutId);\n        var disposed = false;\n        return function () {\n            if (disposed) {\n                return;\n            }\n            disposed = true;\n            _this.references--;\n            setTimeout(function () {\n                if (!_this.references) {\n                    _this.dispose();\n                }\n            });\n        };\n    };\n    InternalQueryReference.prototype.softRetain = function () {\n        var _this = this;\n        this.softReferences++;\n        var disposed = false;\n        return function () {\n            // Tracking if this has already been called helps ensure that\n            // multiple calls to this function won't decrement the reference\n            // counter more than it should. Subsequent calls just result in a noop.\n            if (disposed) {\n                return;\n            }\n            disposed = true;\n            _this.softReferences--;\n            setTimeout(function () {\n                if (!_this.softReferences && !_this.references) {\n                    _this.dispose();\n                }\n            });\n        };\n    };\n    InternalQueryReference.prototype.didChangeOptions = function (watchQueryOptions) {\n        var _this = this;\n        return OBSERVED_CHANGED_OPTIONS.some(function (option) {\n            return option in watchQueryOptions &&\n                !equal(_this.watchQueryOptions[option], watchQueryOptions[option]);\n        });\n    };\n    InternalQueryReference.prototype.applyOptions = function (watchQueryOptions) {\n        var _a = this.watchQueryOptions, currentFetchPolicy = _a.fetchPolicy, currentCanonizeResults = _a.canonizeResults;\n        // \"standby\" is used when `skip` is set to `true`. Detect when we've\n        // enabled the query (i.e. `skip` is `false`) to execute a network request.\n        if (currentFetchPolicy === \"standby\" &&\n            currentFetchPolicy !== watchQueryOptions.fetchPolicy) {\n            this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n        }\n        else {\n            this.observable.silentSetOptions(watchQueryOptions);\n            if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {\n                this.result = __assign(__assign({}, this.result), this.observable.getCurrentResult());\n                this.promise = createFulfilledPromise(this.result);\n            }\n        }\n        return this.promise;\n    };\n    InternalQueryReference.prototype.listen = function (listener) {\n        var _this = this;\n        this.listeners.add(listener);\n        return function () {\n            _this.listeners.delete(listener);\n        };\n    };\n    InternalQueryReference.prototype.refetch = function (variables) {\n        return this.initiateFetch(this.observable.refetch(variables));\n    };\n    InternalQueryReference.prototype.fetchMore = function (options) {\n        return this.initiateFetch(this.observable.fetchMore(options));\n    };\n    InternalQueryReference.prototype.dispose = function () {\n        this.subscription.unsubscribe();\n        this.onDispose();\n    };\n    InternalQueryReference.prototype.onDispose = function () {\n        // noop. overridable by options\n    };\n    InternalQueryReference.prototype.handleNext = function (result) {\n        var _a;\n        switch (this.promise.status) {\n            case \"pending\": {\n                // Maintain the last successful `data` value if the next result does not\n                // have one.\n                if (result.data === void 0) {\n                    result.data = this.result.data;\n                }\n                this.result = result;\n                (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, result);\n                break;\n            }\n            default: {\n                // This occurs when switching to a result that is fully cached when this\n                // class is instantiated. ObservableQuery will run reobserve when\n                // subscribing, which delivers a result from the cache.\n                if (result.data === this.result.data &&\n                    result.networkStatus === this.result.networkStatus) {\n                    return;\n                }\n                // Maintain the last successful `data` value if the next result does not\n                // have one.\n                if (result.data === void 0) {\n                    result.data = this.result.data;\n                }\n                this.result = result;\n                this.promise = createFulfilledPromise(result);\n                this.deliver(this.promise);\n                break;\n            }\n        }\n    };\n    InternalQueryReference.prototype.handleError = function (error) {\n        var _a;\n        this.subscription.unsubscribe();\n        this.subscription = this.observable.resubscribeAfterError(this.handleNext, this.handleError);\n        switch (this.promise.status) {\n            case \"pending\": {\n                (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, error);\n                break;\n            }\n            default: {\n                this.promise = createRejectedPromise(error);\n                this.deliver(this.promise);\n            }\n        }\n    };\n    InternalQueryReference.prototype.deliver = function (promise) {\n        this.listeners.forEach(function (listener) { return listener(promise); });\n    };\n    InternalQueryReference.prototype.initiateFetch = function (returnedPromise) {\n        var _this = this;\n        this.promise = this.createPendingPromise();\n        this.promise.catch(function () { });\n        // If the data returned from the fetch is deeply equal to the data already\n        // in the cache, `handleNext` will not be triggered leaving the promise we\n        // created in a pending state forever. To avoid this situtation, we attempt\n        // to resolve the promise if `handleNext` hasn't been run to ensure the\n        // promise is resolved correctly.\n        returnedPromise\n            .then(function () {\n            // In the case of `fetchMore`, this promise is resolved before a cache\n            // result is emitted due to the fact that `fetchMore` sets a `no-cache`\n            // fetch policy and runs `cache.batch` in its `.then` handler. Because\n            // the timing is different, we accidentally run this update twice\n            // causing an additional re-render with the `fetchMore` result by\n            // itself. By wrapping in `setTimeout`, this should provide a short\n            // delay to allow the `QueryInfo.notify` handler to run before this\n            // promise is checked.\n            // See https://github.com/apollographql/apollo-client/issues/11315 for\n            // more information\n            setTimeout(function () {\n                var _a;\n                if (_this.promise.status === \"pending\") {\n                    // Use the current result from the observable instead of the value\n                    // resolved from the promise. This avoids issues in some cases where\n                    // the raw resolved value should not be the emitted value, such as\n                    // when a `fetchMore` call returns an empty array after it has\n                    // reached the end of the list.\n                    //\n                    // See the following for more information:\n                    // https://github.com/apollographql/apollo-client/issues/11642\n                    _this.result = _this.observable.getCurrentResult();\n                    (_a = _this.resolve) === null || _a === void 0 ? void 0 : _a.call(_this, _this.result);\n                }\n            });\n        })\n            .catch(function (error) { var _a; return (_a = _this.reject) === null || _a === void 0 ? void 0 : _a.call(_this, error); });\n        return returnedPromise;\n    };\n    InternalQueryReference.prototype.subscribeToQuery = function () {\n        var _this = this;\n        this.subscription = this.observable\n            .filter(function (result) { return !equal(result.data, {}) && !equal(result, _this.result); })\n            .subscribe(this.handleNext, this.handleError);\n    };\n    InternalQueryReference.prototype.setResult = function () {\n        // Don't save this result as last result to prevent delivery of last result\n        // when first subscribing\n        var result = this.observable.getCurrentResult(false);\n        if (equal(result, this.result)) {\n            return;\n        }\n        this.result = result;\n        this.promise =\n            (result.data &&\n                (!result.partial || this.watchQueryOptions.returnPartialData)) ?\n                createFulfilledPromise(result)\n                : this.createPendingPromise();\n    };\n    InternalQueryReference.prototype.createPendingPromise = function () {\n        var _this = this;\n        return wrapPromiseWithState(new Promise(function (resolve, reject) {\n            _this.resolve = resolve;\n            _this.reject = reject;\n        }));\n    };\n    return InternalQueryReference;\n}());\nexport { InternalQueryReference };\n//# sourceMappingURL=QueryReference.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}