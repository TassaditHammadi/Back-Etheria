{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { equal } from \"@wry/equality\";\nimport { createFulfilledPromise, wrapPromiseWithState } from \"../../../utilities/index.js\";\nvar FragmentReference = /** @class */function () {\n  function FragmentReference(client, watchFragmentOptions, options) {\n    var _this = this;\n    this.key = {};\n    this.listeners = new Set();\n    this.references = 0;\n    this.dispose = this.dispose.bind(this);\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.observable = client.watchFragment(watchFragmentOptions);\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n    var diff = this.getDiff(client, watchFragmentOptions);\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this fragmentRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    var startDisposeTimer = function () {\n      var _a;\n      if (!_this.references) {\n        _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a = options.autoDisposeTimeoutMs) !== null && _a !== void 0 ? _a : 30000);\n      }\n    };\n    this.promise = diff.complete ? createFulfilledPromise(diff.result) : this.createPendingPromise();\n    this.subscribeToFragment();\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n  FragmentReference.prototype.listen = function (listener) {\n    var _this = this;\n    this.listeners.add(listener);\n    return function () {\n      _this.listeners.delete(listener);\n    };\n  };\n  FragmentReference.prototype.retain = function () {\n    var _this = this;\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    var disposed = false;\n    return function () {\n      if (disposed) {\n        return;\n      }\n      disposed = true;\n      _this.references--;\n      setTimeout(function () {\n        if (!_this.references) {\n          _this.dispose();\n        }\n      });\n    };\n  };\n  FragmentReference.prototype.dispose = function () {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  };\n  FragmentReference.prototype.onDispose = function () {\n    // noop. overridable by options\n  };\n  FragmentReference.prototype.subscribeToFragment = function () {\n    this.subscription = this.observable.subscribe(this.handleNext.bind(this), this.handleError.bind(this));\n  };\n  FragmentReference.prototype.handleNext = function (result) {\n    var _a;\n    switch (this.promise.status) {\n      case \"pending\":\n        {\n          if (result.complete) {\n            return (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, result.data);\n          }\n          this.deliver(this.promise);\n          break;\n        }\n      case \"fulfilled\":\n        {\n          // This can occur when we already have a result written to the cache and\n          // we subscribe for the first time. We create a fulfilled promise in the\n          // constructor with a value that is the same as the first emitted value\n          // so we want to skip delivering it.\n          if (equal(this.promise.value, result.data)) {\n            return;\n          }\n          this.promise = result.complete ? createFulfilledPromise(result.data) : this.createPendingPromise();\n          this.deliver(this.promise);\n        }\n    }\n  };\n  FragmentReference.prototype.handleError = function (error) {\n    var _a;\n    (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, error);\n  };\n  FragmentReference.prototype.deliver = function (promise) {\n    this.listeners.forEach(function (listener) {\n      return listener(promise);\n    });\n  };\n  FragmentReference.prototype.createPendingPromise = function () {\n    var _this = this;\n    return wrapPromiseWithState(new Promise(function (resolve, reject) {\n      _this.resolve = resolve;\n      _this.reject = reject;\n    }));\n  };\n  FragmentReference.prototype.getDiff = function (client, options) {\n    var cache = client.cache;\n    var from = options.from,\n      fragment = options.fragment,\n      fragmentName = options.fragmentName;\n    var diff = cache.diff(__assign(__assign({}, options), {\n      query: cache[\"getFragmentDoc\"](fragment, fragmentName),\n      returnPartialData: true,\n      id: from,\n      optimistic: true\n    }));\n    return __assign(__assign({}, diff), {\n      result: client[\"queryManager\"].maskFragment({\n        fragment: fragment,\n        fragmentName: fragmentName,\n        data: diff.result\n      })\n    });\n  };\n  return FragmentReference;\n}();\nexport { FragmentReference };","map":{"version":3,"names":["__assign","equal","createFulfilledPromise","wrapPromiseWithState","FragmentReference","client","watchFragmentOptions","options","_this","key","listeners","Set","references","dispose","bind","handleNext","handleError","observable","watchFragment","onDispose","diff","getDiff","startDisposeTimer","_a","autoDisposeTimeoutId","setTimeout","autoDisposeTimeoutMs","promise","complete","result","createPendingPromise","subscribeToFragment","then","prototype","listen","listener","add","delete","retain","clearTimeout","disposed","subscription","unsubscribe","subscribe","status","resolve","call","data","deliver","value","error","reject","forEach","Promise","cache","from","fragment","fragmentName","query","returnPartialData","id","optimistic","maskFragment"],"sources":["C:/Users/hp/Desktop/Projetyacine/agence-voyage/node_modules/@apollo/client/react/internal/cache/FragmentReference.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { equal } from \"@wry/equality\";\nimport { createFulfilledPromise, wrapPromiseWithState, } from \"../../../utilities/index.js\";\nvar FragmentReference = /** @class */ (function () {\n    function FragmentReference(client, watchFragmentOptions, options) {\n        var _this = this;\n        this.key = {};\n        this.listeners = new Set();\n        this.references = 0;\n        this.dispose = this.dispose.bind(this);\n        this.handleNext = this.handleNext.bind(this);\n        this.handleError = this.handleError.bind(this);\n        this.observable = client.watchFragment(watchFragmentOptions);\n        if (options.onDispose) {\n            this.onDispose = options.onDispose;\n        }\n        var diff = this.getDiff(client, watchFragmentOptions);\n        // Start a timer that will automatically dispose of the query if the\n        // suspended resource does not use this fragmentRef in the given time. This\n        // helps prevent memory leaks when a component has unmounted before the\n        // query has finished loading.\n        var startDisposeTimer = function () {\n            var _a;\n            if (!_this.references) {\n                _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a = options.autoDisposeTimeoutMs) !== null && _a !== void 0 ? _a : 30000);\n            }\n        };\n        this.promise =\n            diff.complete ?\n                createFulfilledPromise(diff.result)\n                : this.createPendingPromise();\n        this.subscribeToFragment();\n        this.promise.then(startDisposeTimer, startDisposeTimer);\n    }\n    FragmentReference.prototype.listen = function (listener) {\n        var _this = this;\n        this.listeners.add(listener);\n        return function () {\n            _this.listeners.delete(listener);\n        };\n    };\n    FragmentReference.prototype.retain = function () {\n        var _this = this;\n        this.references++;\n        clearTimeout(this.autoDisposeTimeoutId);\n        var disposed = false;\n        return function () {\n            if (disposed) {\n                return;\n            }\n            disposed = true;\n            _this.references--;\n            setTimeout(function () {\n                if (!_this.references) {\n                    _this.dispose();\n                }\n            });\n        };\n    };\n    FragmentReference.prototype.dispose = function () {\n        this.subscription.unsubscribe();\n        this.onDispose();\n    };\n    FragmentReference.prototype.onDispose = function () {\n        // noop. overridable by options\n    };\n    FragmentReference.prototype.subscribeToFragment = function () {\n        this.subscription = this.observable.subscribe(this.handleNext.bind(this), this.handleError.bind(this));\n    };\n    FragmentReference.prototype.handleNext = function (result) {\n        var _a;\n        switch (this.promise.status) {\n            case \"pending\": {\n                if (result.complete) {\n                    return (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, result.data);\n                }\n                this.deliver(this.promise);\n                break;\n            }\n            case \"fulfilled\": {\n                // This can occur when we already have a result written to the cache and\n                // we subscribe for the first time. We create a fulfilled promise in the\n                // constructor with a value that is the same as the first emitted value\n                // so we want to skip delivering it.\n                if (equal(this.promise.value, result.data)) {\n                    return;\n                }\n                this.promise =\n                    result.complete ?\n                        createFulfilledPromise(result.data)\n                        : this.createPendingPromise();\n                this.deliver(this.promise);\n            }\n        }\n    };\n    FragmentReference.prototype.handleError = function (error) {\n        var _a;\n        (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, error);\n    };\n    FragmentReference.prototype.deliver = function (promise) {\n        this.listeners.forEach(function (listener) { return listener(promise); });\n    };\n    FragmentReference.prototype.createPendingPromise = function () {\n        var _this = this;\n        return wrapPromiseWithState(new Promise(function (resolve, reject) {\n            _this.resolve = resolve;\n            _this.reject = reject;\n        }));\n    };\n    FragmentReference.prototype.getDiff = function (client, options) {\n        var cache = client.cache;\n        var from = options.from, fragment = options.fragment, fragmentName = options.fragmentName;\n        var diff = cache.diff(__assign(__assign({}, options), { query: cache[\"getFragmentDoc\"](fragment, fragmentName), returnPartialData: true, id: from, optimistic: true }));\n        return __assign(__assign({}, diff), { result: client[\"queryManager\"].maskFragment({\n                fragment: fragment,\n                fragmentName: fragmentName,\n                data: diff.result,\n            }) });\n    };\n    return FragmentReference;\n}());\nexport { FragmentReference };\n//# sourceMappingURL=FragmentReference.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}